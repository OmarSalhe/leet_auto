Medium,2270. Number of Ways to Split Array,py
'''
You are given a 0-indexed integer array nums of length n.

nums contains a valid split at index i if the following are true:

The sum of the first i + 1 elements is greater than or equal to the sum of the last n - i - 1 elements.
    - n - i - 1 = (n - 1) - i = remaining elements
    - i + 1 -> shifting to 1-index -> includes ith element
    - the sum of the first x elements must be >= to the sum of the last x - 1 elements
There is at least one element to the right of i. That is, 0 <= i < n - 1.
    - part cannot be made at the end of arr or at the start -> splits are non-empty

Return the number of valid splits in nums.

return the number of times the sum of the first i + 1 elements >= the remaining elements

*only one split per iteration -> only splitting into two*

i = 0, len(nums) - 1 always fails
len(nums) = big -> O(n) needed

slowest part = finding sum for every range -> need to find sum at every index first (prefix sum)

nums = [10,4,-8,7]
Decision:
    x = 1
    left = 10, right = 4 - 8 + 7 = 5 -> valid
    x = 2
    left = 10 + 4 = right = -8 + 7 = -1 -> valid
    x = 3
    left = 10 + 4 - 8 = 6, right = 7 -> invalid

Generalized:
    for x in [1, len(nums) - 2]:
        if prefix[x] >= prefix[n - 1] - prefix[x]:
            valid part formed
'''
class Solution:
    def waysToSplitArray(self, nums: List[int]) -> int:
        n = len(nums)
        prefix = [0] * (n + 1)

        for i in range(1, n + 1):
            prefix[i] += prefix[i - 1] + nums[i - 1]
        
        valid_part = 0
        for i in range(1, n):
            if prefix[i] >= prefix[n] - prefix[i]:
                valid_part += 1
        
        return valid_part
Easy,2185. Counting Words With a Given Prefix,py
'''
You are given an array of strings words and a string pref.

Return the number of strings in words that contain pref as a prefix.

A prefix of a string s is any leading contiguous substring of s.

prefix at start -> check first len(pref) letters

approach:
    for word in words:
        if pref matches first len(pref) letters in word:
            increment count

can do window check type of thing if slicing less intuitive
i.e.
    if pref[i] == word[j]:
        increment both
    else:
        don't match -> stop immediately
    
    if i == len(pref):
        letters matched len(pref) times AKA same words
'''

class Solution:
    def prefixCount(self, words: List[str], pref: str) -> int:
        count = 0
        for word in words:
            if word[:len(pref)] == pref:
                count += 1
        return count
Medium,1769. Minimum Number of Operations to Move All Balls to Each Box,py
'''
You have n boxes. You are given a binary string boxes of length n, where boxes[i] is '0' if the ith box 
is empty, and '1' if it contains one ball.
    - balls initially separate
    - think arr instead of str

In one operation, you can move one ball from a box to an adjacent box. Box i is adjacent to box j if abs(i - j) == 1. 
Note that after doing so, there may be more than one ball in some boxes.
    - one ball at a time
    - total balls <= boxes
    - one unit = one adj box = 1 -> ops to any box = 1 * abs(i - j) = 1 unit * num of boxes

Return an array answer of size n, where answer[i] is the minimum number of operations needed to move all the balls to the ith box.
    - assuming boxes form a linear path (non-circular), min ops = dist to box (or index)
    - only one target box per query
        - query = each index as the target

Each answer[i] is calculated considering the initial state of the boxes.
    - some value remains constant
        - empty boxes and starting positions

total dist = abs(i1 - j) + abs(i2 - j) + ... + abs(in - j)
           = abs(i1 + i2 + ... + in - j*n) -> for every non-empty box
           = abs(sum - j*n); sum = n*(n+1) / 2, but this fails to remove contributions from empty boxes
        -> = abs(sum - j * n - dist of empty boxes); dist of empty = sum of (empty indices + 1) - j * (num of empty boxes)

bugs out with boxes = "001011", indices 3, 4
because of symmetry -> some indices are negated. to offset, just split indices centered about j (so both sides remain positive)
eq doesn't change (i.e. abs(7-5) = abs(3-5)) so only change is to sum the intervals sep -> (prefix sum)

'''
class Solution:
    def minOperations(self, boxes: str) -> List[int]:
        n = len(boxes)
        prefix = [0] * (n + 1)
        not_empty = [0] * (n + 1)

        for i in range(1, n + 1):
            if boxes[i - 1] == '1':
                prefix[i] = i
                not_empty[i] = 1
            not_empty[i] += not_empty[i - 1]
            prefix[i] += prefix[i - 1]
        
        answer = [0] * n
        for i in range(1, n + 1):
            left = abs(prefix[i] - i * not_empty[i])
            right = prefix[n] - prefix[i] - i * (not_empty[n] - not_empty[i])
            answer[i - 1] = left + right
            print(left, right)
        return answer
Easy,1408. String Matching in an Array,py
'''
Given an array of string words, return all strings in words that is a substring of another word.
You can return the answer in any order.
    - return word if word is found in another word

A substring is a contiguous sequence of characters within a string
    - sub < main
    - ltrs are consecutive

len(words), len(words[i]) = small -> bf allowed
bf = search for word in every word = O(n * m)
'''
class Solution:
    def stringMatching(self, words: List[str]) -> List[str]:
        s = ' '.join(words)
        return [word for word in words if s.count(word) > 1]
