Medium,2938. Separate Black and White Balls,py
class Solution:
    def minimumSteps(self, s: str) -> int:
        n = len(s)
        swaps = 0
        # all white balls belong on the left side -> start of str
        w = 0
        # ensure you start where you can perform swaps
        while w < n and s[w] == '0' :
            w += 1

        # if already separated, no swapping needed
        if w == n:
            return swaps
        
        # swaps = dist to closest white ball
        for i in range(w, n):
            if s[i] == '0':
                swaps += i - w
                w += 1
        return swaps

        """
        Time Comlpexity = going through n letters and arithmetic = O(n+1) ~ O(n)
        Space Complexity = variables = O(1)
        """
EOS
Medium,2981. Find Longest Special Substring That Occurs Thrice I,py
class Solution:
    def maximumLength(self, s: str) -> int:
        intervals = collections.defaultdict(list)
        start, end = 0, 0
        while end < len(s):
            start = end
            while end < len(s) and s[start] == s[end]:
                end += 1
            intervals[s[start]].append((start, end))

        matrix = [[0 for _ in range(len(s) + 1)] for _ in range(26)]
        for ltr in intervals:
            print(intervals[ltr])
            for start, end in intervals[ltr]:
                size = end - start
                for i in range(1, size + 1):
                    matrix[ord(ltr) - ord('a')][i] += size - i + 1
        
        candidet = -1
        for ltr in intervals:
            row = matrix[ord(ltr) - ord('a')]
            for i in range(len(row)):
                if row[i] >= 3:
                    candidet = max(candidet, i)

        return candidet
EOS
Easy,3042. Count Prefix and Suffix Pairs I,py
'''
You are given a 0-indexed string array words.

Let's define a boolean function isPrefixAndSuffix that takes two strings, str1 and str2:

isPrefixAndSuffix(str1, str2) returns true if str1 is both a 
prefix and a suffix of str2, and false otherwise.
    - same pattern at start + end
    - str1 is given -> pattern is given
    - str1 must be smaller than str 2

For example, isPrefixAndSuffix("aba", "ababa") is true because "aba" is a prefix of "ababa" and also a suffix,
but isPrefixAndSuffix("abc", "abcd") is false.
    - prefix and suffix can intersect / don't need to be distinct

Return an integer denoting the number of index pairs (i, j) such that i < j, and isPrefixAndSuffix(words[i], words[j]) is true.
    - only one pair in list
    - guaranteed that str1 comes before str2

make isPrefixAndSuffix -> use as condition to find pair -> return number of pairs found

isPrefixAndSuffix defn:
    use two windows (one at start and other at end):
        if both left and right window == eachother and target -> expand window
        else -> stop (return False)

        repeat until window of len(target) reached
        return True

len(words), len(words[i]) = small -> O(n2) allowed

no way of knowing which str is str2 and can't sort since order matters so bf
bf = for every str:
        cur = current str
        for every str before cur:
            if len(cur) < len(str) and isPrefixAndSuffix is True:
                count_of_pair ++
    return count_of_pair
'''

class Solution:
    def countPrefixSuffixPairs(self, words: List[str]) -> int:
        n = len(words)
        count_of_pairs = 0
        for i in range(n):
            for j in range(i + 1, n):
                if words[j].startswith(words[i]) and words[j].endswith(words[i]):
                    count_of_pairs += 1
        return count_of_pairs
EOS
Medium,3097. Shortest Subarray With OR at Least K II,py
class Solution:
    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:
        min_length = float("inf")
        window_start = window_end = 0
        bit_counts = [0] * 32  # Tracks count of set bits at each position

        # Expand window until end of array
        while window_end < len(nums):
            # Add current number to window
            self._update_bit_counts(bit_counts, nums[window_end], 1)

            # Contract window while OR value is valid
            while (
                window_start <= window_end
                and self._convert_bits_to_num(bit_counts) >= k
            ):
                # Update minimum length found so far
                min_length = min(min_length, window_end - window_start + 1)

                # Remove leftmost number and shrink window
                self._update_bit_counts(bit_counts, nums[window_start], -1)
                window_start += 1

            window_end += 1

        return -1 if min_length == float("inf") else min_length

    def _update_bit_counts(
        self, bit_counts: list, number: int, delta: int
    ) -> None:
        # Update counts for each set bit in the number
        for pos in range(32):
            if number & (1 << pos):
                bit_counts[pos] += delta

    def _convert_bits_to_num(self, bit_counts: list) -> int:
        # Convert bit counts to number using OR operation
        result = 0
        for pos in range(32):
            if bit_counts[pos]:
                result |= 1 << pos
        return result
EOS
Medium,3133. Minimum Array End,py
class Solution:
    def minEnd(self, n: int, x: int) -> int:
        result = x
        n -= 1  # Reducing n by 1 to exclude x from the iteration
        mask = 1

        # Step 1: Iterate while n > 0, using mask for bit positions
        while n > 0:
            # Step 2: If the corresponding bit in x is 0
            if (mask & x) == 0:
                # Set the bit in result based on least significant bit of n
                result |= (n & 1) * mask
                # Shift n right by 1 to process next bit
                n >>= 1
            # Shift mask left by 1 for next iteration
            mask <<= 1

        return result
EOS
EOS
