Medium,2466. Count Ways to Build Good Strings,py
'''
Given the integers zero, one, low, and high, we can construct a string by starting with an empty 
string, and then at each step perform either of the following:

Append the character '0' zero times.
Append the character '1' one times.
This can be performed any number of times.
    - must append all at once
        i.e. if one = 5, zero = 1 -> append 1 = 11111
    - if one, zero > high, cannot use respective number
        - 1 <= zero, one <= low -> dont need to worry

A good string is a string constructed by the above process having a length between low and high (inclusive).
    - consider all strs low ≤ len ≤ high

Return the number of different good strings that can be constructed satisfying these properties.
    - order of strs matter -> no dups
        - keep track of strs made -> if sim
        - use combinatorics -> handles dups BUT factorials

Since the answer can be large, return it modulo 109 + 7.
    - applied at the end

goal: form all possible bit strs from len high -> low, containing zero 0s and one 1s, and return the amount % 1000000007

Topics:
    - counting/combinations
        - how many possibility per index -> count[i] = count[i-1] * possibility; 0 <= possibility <= 2
    - combinatorics
        - how many ways can one fit into [low, high]?

1 <= low <= high <= 10**5
    - O(n) approach needed, sim too slow
    - (high - low) = 10***5 - 1 wc, range too large to iterate


low = 3, high = 3, zero = 1, one = 1
Decision (sim):
    if len > high: stop
    count = 1 if cur bit str >= low else 0

    append one 1 (if len + one <= high) -> len += one, append 0/1 (if ...)
    append zero 0 (if len + zero <= high) -> len += zero, append 0/1 (if ...)


_ _ _ -> each slot can be either zero/one so 2*2*2 -> why? if none chosen one/zero can fit in low=high=3 spots

low = 3, high = 3, zero = 1, one = 1
Decision (counting):
    if one + i <= high:
        count[i] += count[i-1]
    if zero + i <= high:
        count[i] += count[i-1]
    
    if neither:
        break -> if none can fit at that point, none can fit later
    
    sum all count[i]s where low - 1 < i < high
'''

class Solution:
    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
        count = [0] * (high + 1)
        count[0] = 1

        res = 0
        for i in range(1, high + 1):
            count[i] = ((count[i-one] if i >= one else 0) + (count[i-zero] if i>=zero else 0)) % 1000000007
            if i >= low and i <= high:
                res = (res + count[i])% 1000000007
        return res

        #     if i - one > -1: count[i] += count[i - one]
        #     if i - zero > -1: count[i] += count[i - zero]
        #     if i >= low:
        #         res += count[i]
        # return res % 1000000007

        # @cache
        # def count_cont(length: int, low: int, high: int, one: int, zero: int):
        #     if length > high: return 0

        #     count = 1 if length >= low else 0

        #     add_one = 0
        #     if one + length <= high:
        #         add_one = count_cont(length + one, low, high, one, zero) % 1000000007

        #     add_zero = 0
        #     if zero + length <= high:
        #         add_zero = count_cont(length + zero, low, high, one, zero) % 1000000007
            
        #     count += add_one + add_zero
        #     return count % 1000000007

        # return count_cont(0, low, high, zero, one)
EOS
Medium,2461. Maximum Sum of Distinct Subarrays With Length K,py
class Solution:
    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        max_win = 0 # maximum k-length subarray sum
        win_sum = 0 # current k-length subarray sum
        win_nums = collections.defaultdict(int) # numbers in cur k-length subarray

        n = len(nums)
        left, right = 0, 0

        while right < n: # expand right bound to end of array
            win_nums[nums[right]] += 1
            win_sum += nums[right]

            # contract window if any duplicates arise
            while left <= right and win_nums[nums[right]] > 1:
                # print(f'window: {nums[left: right + 1]}')
                win_sum -= nums[left]
                win_nums[nums[left]] -= 1
                left += 1
            
            if right - left + 1 == k: # if valid k-length window formed
                max_win = max(max_win, win_sum)

                # shift left bound forward
                win_nums[nums[left]] -= 1
                win_sum -= nums[left]

                left += 1

            # shift right bound forward
            right += 1
        
        return max_win
EOS
Medium,2381. Shifting Letters II,py
class Solution:
    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:
        val = [[False, 0] for _ in range(len(s) + 1)]
        for i in range(len(shifts)):
            start, end, direction = shifts[i]
            sign = 1 if direction else -1
            val[start][0], val[start][1] = True, val[start][1] + sign
            val[end + 1][0], val[end + 1][1] = True, val[end + 1][1] - sign
        
        shift = 0
        res = []
        for i in range(len(s)):
            if val[i][0]:
                shift += val[i][1]
            
            res.append(chr((ord(s[i]) + shift - ord('a')) % 26 + ord('a')))
        
        return ''.join(res)
EOS
Medium,2257. Count Unguarded Cells in the Grid,py
from typing import List

class Solution:
    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:
        matrix = [['U' for _ in range(n)] for _ in range(m)]

        for r, c in guards:
            matrix[r][c] = 'G'

        for r, c in walls:
            matrix[r][c] = 'W'


        for r, c in guards:
            i = r - 1
            while i > -1 and matrix[i][c] != 'W' and matrix[i][c] != 'G':
                matrix[i][c] = 'X'
                i -= 1

            i = r + 1
            while i < m and matrix[i][c] != 'W' and matrix[i][c] != 'G':
                matrix[i][c] = 'X'
                i += 1
            
            i = c - 1
            while i > -1 and matrix[r][i] != 'W' and matrix[r][i] != 'G':
                matrix[r][i] = 'X'
                i -= 1
            
            i = c + 1
            while i < n and matrix[r][i] != 'W' and matrix[r][i] != 'G':
                matrix[r][i] = 'X'
                i += 1

        unguarded = 0
        for r in range(m):
            for c in range(n):
                if matrix[r][c] == 'U':
                    unguarded += 1
        return unguarded

        """
        approach #2 (brute-force):
            mark all cells visible to guards as 'guarded'
            stop if wall or bounds
        """

        # seen = set((r, c) for r, c in guards)
        # walls = set((r, c) for r, c in walls)

        # DIR = [(1, 0), (0, 1), (-1, 0), (0, -1)] # down, right, up, left
        # q = collections.deque([(r, c, False, False, False, False) for r, c in guards])
        # while q:
        #     for _ in range(len(q)):
        #         cur_r, cur_c, up, down, left, right = q.popleft()
        #         if (cur_r, cur_c) in walls:
        #             continue

        #         seen.add((cur_r, cur_c)) 

        #         if not up and not down and not left and not right: # if a guard
        #             for dr, dc in DIR:
        #                 r, c = cur_r + dr, cur_c + dc
        #                 if (r < m and r > -1) and (c < n and c > -1): # if in bound
        #                     if dc < 0: # left
        #                         q.append((r, c, False, False, True, False))
        #                     elif dc > 0: # right
        #                         q.append((r, c, False, False, False, True))
        #                     elif dr < 0: # up
        #                         q.append((r, c, True, False, False, False))
        #                     elif dr > 0: # down
        #                         q.append((r, c, False, True, False, False))
        #         else: # else (checking what a guard sees)
        #             if left and cur_c - 1 > -1:
        #                 q.append((cur_r, cur_c - 1, False, False, True, False))
        #             elif right and cur_c + 1 < n:
        #                 q.append((cur_r, cur_c + 1, False, False, False, True))
        #             elif up and cur_r - 1 > -1:
        #                 q.append((cur_r - 1, cur_c, True, False, False, False))
        #             elif down and cur_r + 1 < m:
        #                 q.append((cur_r + 1, cur_c, False, True, False, False))

        # return m * n - len(seen) - len(walls)

        """
        notes: guards see in 4 direction infinite distance
               walls can obstruct view
               count how many squares not in view (blocked or diags?)
               can't see past bounds
               can overlap
        
        approach (bfs type):
            for each guard in graph;
                store into queue


            for each saved guard:
                for each direction
                    go until a wall or OOB
                    save every cell on the way
            
            unguarded cells = total cells - guarded - walls, total cells = area of graph
        """
EOS
Medium,2516. Take K of Each Character From Left and Right,py
class Solution:
    def takeCharacters(self, s: str, k: int) -> int:
        if k == 0:
            return 0

        n = len(s)
        count = [0] * 3
        for i in range(n):
            count[ord(s[i]) - ord('a')] += 1

        if count[0] < k or count[1] < k or count[2] < k:
            return -1


        left, right = 0, 0
        max_win = -1
        while right < n:
            count[ord(s[right]) - ord('a')] -= 1

            while left <= right and (count[0] < k or
                                    count[1] < k or 
                                    count[2] < k):
                count[ord(s[left]) - ord('a')] += 1
                left += 1
            
            max_win = max(max_win, right - left + 1)

            right += 1


        return n - max_win
EOS
EOS
